untyped // so we can use entity.s.  ... maybe too much wasn't a good idea?
global function TitanHealth_Init

global function Titan_PlayerTookDamage
global function Titan_NPCTookDamage

global function GetShieldRegenTime
global function GetShieldRegenDelay
global function PlayerHasAutoEject
global function SetTitanCoreTimer
global function GetTitanCoreTimer

global function AddCreditToTitanCoreBuilderForTitanDamageInflicted
global function AddCreditToTitanCoreBuilderForTitanDamageReceived
global function AddCreditToTitanCoreBuilderForDoomInflicted
global function AddCreditToTitanCoreBuilderForDoomEntered
global function AddCreditToTitanCoreBuilder

// modified to get rid of respawn's hardcode
global function TitanHealth_SetTitanCoreBuilderMultiplier
global function TitanHealth_GetTitanCoreBuilderMultiplier
//

global function TitanShieldRegenThink

global function IsRodeoDamageFromBatteryPack
global function IsKillshot

global function DoomedHealthThink
global function UndoomTitan
global function RestoreTitan

// vanilla missing callback
global function AddCallback_OnTitanUndoomed

// modified for modded titan doom state
global function TitanHealth_SetSoulInfiniteDoomedState
global function TitanHealth_GetSoulInfiniteDoomedState // for score events
global function TitanHealth_SetSoulDoomedHealthLossDamage

// modified for scripted titan shield regen
global function TitanHealth_SetSoulEnableShieldRegen
global function TitanHealth_GetSoulEnableShieldRegen // shared with _utility.gnut, function TitanHasRegenningShield()
global function TitanHealth_SetSoulShieldRegenDelay
global function TitanHealth_SetSoulShieldRegenTime
global function TitanHealth_SetSoulShieldDamageReductionScale
// npc pilot
#if NPC_TITAN_PILOT_PROTOTYPE
global function TitanHealth_SetSoulNPCPilotEjectDelay
#endif

// debug
const bool TITAN_SCRIPTED_SHIELD_REGEN_DEBUG = false
//

global const SIGNAL_TITAN_HEALTH_REGEN = "BeginTitanHealthRegen"
global const SIGNAL_TITAN_SHIELD_REGEN = "BeginTitanShieldRegen"

global const TITAN_HEALTH_REGEN_DELAY_MAX				= 0.7 // 2.2

#if MP
//  PROTO : Was 99, 49 is for test
global const TITAN_REGEN_MIN_DAMAGE = 49
global const TITAN_REGEN_MIN_DAMAGE_DELAY = 0.5
#elseif SP
global const TITAN_REGEN_MIN_DAMAGE = 70
global const TITAN_REGEN_MIN_DAMAGE_DELAY = 0.5
#endif

// titan health system
const TITAN_HEALTH_HISTORY_FALLOFF_START = 0 	// how many seconds until shield begins to regen

const float TITAN_HEALTH_HISTORY_FALLOFF_END = 4.0

struct
{
  	float earn_meter_titan_multiplier

	// vanilla missing callbacks
	array<void functionref( entity, int )> titanUndoomedCallbacks
 
	// modified to get rid of respawn's hardcode
	table<entity, float> soulCoreBuilderMultiplier
	// modified for modded titan doom state
	table<entity, bool> soulInfiniteDoomedState
	table<entity, float> soulDoomedHealthLossDamage
	// modified for scripted titan shield regen
	table<entity, bool> soulEnableShieldRegen
	table<entity, float> soulShieldRegenDelay
	table<entity, float> soulShieldRegenTime
	table<entity, float> soulShieldDamageReductionScale // 1.0 in ttf2

	// npc pilot
	table<entity, float> soulNPCPilotEjectDelay
} file

void function TitanHealth_Init()
{
	RegisterSignal( SIGNAL_TITAN_HEALTH_REGEN )
	RegisterSignal( SIGNAL_TITAN_SHIELD_REGEN )
	RegisterSignal( "Doomed" )
	RegisterSignal( "TitanUnDoomed" )
	RegisterSignal( "StopShieldRegen" )
	RegisterSignal( "WeakTitanHealthInitialized" )

	// vanilla missing
	RegisterSignal( "DoomedHealthThink" )

	file.earn_meter_titan_multiplier = GetCurrentPlaylistVarFloat( "earn_meter_titan_multiplier", 1.0 )

	if ( IsMenuLevel() )
		return

	HealthRegenInit()
	AddSoulInitFunc( TitanShieldRegenThink ) //This runs even if playlist var titan_shield_regen is set to 0 because it also does stuff like give friendly Pilots protection with shield, etc
	AddSoulDeathCallback( Titan_MonarchCleanup )

	// modified callback in _utility.gnut
	AddCallback_ShieldDamageModifier( TitanShieldModifier )

#if TITAN_SCRIPTED_SHIELD_REGEN_DEBUG // debug
	//Riff_ForceSetSpawnAsTitan( eSpawnAsTitan.Always )
	//Riff_ForceTitanExitEnabled( eTitanExitEnabled.Never )
#endif
}

void function UndoomTitan( entity titan, int numSegments )
{
	entity soul = titan.GetTitanSoul()
	string settings = GetSoulPlayerSettings( soul )

	soul.DisableDoomed()
	int maxHealth
	int segmentHealth = GetSegmentHealthForTitan( titan )
	if ( titan.IsNPC() )
	{
		maxHealth = int( GetPlayerSettingsFieldForClassName_Health( settings ) )
		if ( titan.ai.titanSpawnLoadout.setFileMods.contains( "fd_health_upgrade" ) )
			maxHealth += segmentHealth
		if ( soul.soul.titanLoadout.setFileMods.contains( "core_health_upgrade" ) )
			maxHealth += segmentHealth
	}
	else
	{
		maxHealth = int( titan.GetPlayerModHealth() )
	}
	titan.SetMaxHealth( maxHealth )
	titan.SetHealth( segmentHealth * numSegments )
	SetSoulBatteryCount( soul, numSegments )

	titan.Signal( "TitanUnDoomed" )
	UndoomTitan_Body( titan )
	thread TitanShieldRegenThink( soul ) // restart regen

	// vanilla missing functions
	titan.ClearDoomed() // disable doomed animation
	soul.Signal( "TitanUnDoomed" ) // disable doomed health loss
	// vanilla missing callback
	foreach ( callbackFunc in file.titanUndoomedCallbacks )
		callbackFunc( titan, numSegments )
}

void function RestoreTitan( entity titan, float percent = 0.625 )
{
	entity soul = titan.GetTitanSoul()
	if ( soul.IsDoomed() )
		UndoomTitan( titan, 1 )

	soul.nextRegenTime = 0.0
	soul.SetShieldHealth( soul.GetShieldHealthMax() )
	int minHealth = int( titan.GetMaxHealth() * percent )
	if ( titan.GetHealth() < minHealth )
	{
		titan.SetHealth( minHealth )
		int segmentHealth = GetSegmentHealthForTitan( titan )
		int segments = int( minHealth / float( segmentHealth ) )
		SetSoulBatteryCount( soul, segments )
	}
}

bool function IsRodeoDamage( entity soul, var damageInfo )
{
	entity titan 	= soul.GetTitan()
	entity attacker  = DamageInfo_GetAttacker( damageInfo )
	if ( !attacker.IsPlayer() )
	{
		entity rider = GetRodeoPilot( titan )
		if ( rider == attacker )
			return true
		else
			return false
	}

	if ( attacker.GetTitanSoulBeingRodeoed() != soul )
		return false

	return true
}

bool function IsCoopRodeoDamage( entity soul, var damageInfo )
{
	entity titan 	= soul.GetTitan()
	entity attacker = DamageInfo_GetAttacker( damageInfo )
	entity rider = GetRodeoPilot( titan )
	if ( rider == attacker )
		return true
	else
		return false

	unreachable
}


void function CheckRodeoRiderHitsTitan( entity soul, var damageInfo )
{
	if ( IsRodeoDamage( soul, damageInfo )  )
	{
		//Set Last Attack Time so warning is triggered
		soul.SetLastRodeoHitTime( Time() )

		DamageInfo_AddCustomDamageType( damageInfo, DF_RODEO )
	}
}

bool function ShouldMultiplyRodeoDamage( var damageInfo )
{
	switch ( DamageInfo_GetDamageSourceIdentifier( damageInfo ) )
	{
		case eDamageSourceId.mp_weapon_smr:
		case eDamageSourceId.mp_titanability_smoke:
			return false

		case eDamageSourceId.mp_weapon_defender :
			return true
	}

	if ( DamageInfo_GetCustomDamageType( damageInfo ) & DF_EXPLOSION )
		return false

	return true
}

bool function IsRodeoDamageFromBatteryPack( entity soul, var damageInfo )
{
	if ( !IsRodeoDamage( soul, damageInfo ) )
		return false

	if ( DamageInfo_GetCustomDamageType( damageInfo ) != damageTypes.rodeoBatteryRemoval )
		return false

	return true
}


int function ShieldHealthUpdate( entity titan, var damageInfo, bool critHit )
{
	entity soul = titan.GetTitanSoul()
	if ( DamageInfo_GetForceKill( damageInfo ) )
	{
		soul.SetShieldHealth( 0 )
		return 0
	}

	if ( DamageInfo_GetCustomDamageType( damageInfo ) & DF_BYPASS_SHIELD )
		return 0

	float damage = DamageInfo_GetDamage( damageInfo )
	int damageType = DamageInfo_GetCustomDamageType( damageInfo )

	Assert( soul == titan.GetTitanSoul() )
	int shieldHealth = soul.GetShieldHealth()

	if ( soul.e.forcedRegenTime <= Time() )
		soul.nextRegenTime = CalculateNextRegenTime( damage, damageType, critHit, expect float( soul.nextRegenTime ), GetShieldRegenDelay( soul ) )

	int result = 0
	if ( shieldHealth )
	{
		DamageInfo_AddCustomDamageType( damageInfo, DF_SHIELD_DAMAGE )
		result = int( ShieldModifyDamage( titan, damageInfo ) )
	}
	else
	{
		TakeAwayFriendlyRodeoPlayerProtection( titan )
	}

	return result
}


void function PlayerOrNPCTitanTookDamage( entity titan, var damageInfo, bool critHit, TitanDamage titanDamage )
{
	entity soul = titan.GetTitanSoul()

	if ( !IsValid( soul ) ) //Defensive fix for transient times in frame where Titan can have no soul but be damaged, e.g. immediately after embark
		return

	// zero out small forces
	if ( LengthSqr( DamageInfo_GetDamageForce( damageInfo ) ) < 30000 * 30000 )
		DamageInfo_SetDamageForce( damageInfo, < 0, 0, 0 > )

	titanDamage.shieldDamage = CheckSpecialCaseShieldDamage( soul, titan, damageInfo )
	if ( titanDamage.shieldDamage < 0 )
	{
		CheckRodeoRiderHitsTitan( soul, damageInfo )
		titanDamage.shieldDamage = ShieldHealthUpdate( titan, damageInfo, critHit )
	}

	HandleKillshot( titan, damageInfo, titanDamage )

	// health regen based on how much damage dealt to titan
	float damage = DamageInfo_GetDamage( damageInfo )
	int damageType = DamageInfo_GetCustomDamageType( damageInfo )
	bool rodeoDamage = ( ( DamageInfo_GetCustomDamageType( damageInfo ) & DF_RODEO ) > 0 )

	if ( soul.e.forcedRegenTime <= Time() )
		soul.nextHealthRegenTime = CalculateNextRegenTime( damage, damageType, critHit || rodeoDamage, expect float( soul.nextHealthRegenTime ), GetHealthRegenDelay( soul ) )
}

int function CheckSpecialCaseShieldDamage( entity soul, entity titan, var damageInfo )
{
	if ( DamageInfo_GetDamageSourceIdentifier( damageInfo ) == damagedef_suicide )
		return 0

	// no protection from doomed health loss
	if ( DamageInfo_GetCustomDamageType( damageInfo ) & DF_DOOMED_HEALTH_LOSS )
		return 0

	if ( IsTitanWithinBubbleShield( titan ) || TitanHasBubbleShieldWeapon( titan ) )
	{
		DamageInfo_SetDamage( damageInfo, 0 )
		return 0
	}

	return -1
}

void function Titan_NPCTookDamage( entity titan, var damageInfo, TitanDamage titanDamage )
{
	Assert( titan.IsTitan() )
	Assert( DamageInfo_GetDamage( damageInfo ) > 0 )

	// dead entities can take damage
	if ( !IsAlive( titan ) )
		return

	entity soul = titan.GetTitanSoul()

	if ( !IsValid( soul ) ) //Defensive fix for transient times in frame where Titan can have no soul but be damaged, e.g. immediately after embark
		return

	bool critHit = false
	if ( CritWeaponInDamageInfo( damageInfo ) )
		critHit = IsCriticalHit( DamageInfo_GetAttacker( damageInfo ), titan, DamageInfo_GetHitBox( damageInfo ), DamageInfo_GetDamage( damageInfo ), DamageInfo_GetDamageType( damageInfo ) )

	if ( critHit )
		DamageInfo_AddCustomDamageType( damageInfo, DF_CRITICAL )

	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if ( HeavyArmorCriticalHitRequired( damageInfo ) && CritWeaponInDamageInfo( damageInfo ) && !critHit && IsValid( attacker ) && !attacker.IsTitan())
	{
		float shieldHealth = float( titan.GetTitanSoul().GetShieldHealth() )
		float damage = DamageInfo_GetDamage( damageInfo )
		if ( shieldHealth - damage <= 0 )
		{
			if ( shieldHealth > 0 )
				DamageInfo_SetDamage( damageInfo, shieldHealth )
			else
				DamageInfo_SetDamage( damageInfo, 0 )
		}
	}

	PlayerOrNPCTitanTookDamage( titan, damageInfo, critHit, titanDamage )

	RecordDamageToNPCTitanSoul( soul, damageInfo )

	entity owner = GetPetTitanOwner( titan )
	if ( IsValid( owner ) )
		AutoTitan_TryMultipleTitanCallout( titan, damageInfo )

	if ( GetDoomedState( titan ) )
		titanDamage.shieldDamage = 0
}

void function Titan_PlayerTookDamage( entity player, var damageInfo, entity attacker, bool critHit, TitanDamage titanDamage )
{
	Assert( player.IsTitan() )

	float damage = DamageInfo_GetDamage( damageInfo )

	if ( !IsAlive( player ) )
		return

	entity soul = player.GetTitanSoul()
	if ( !IsValid( soul ) ) //Defensive fix for transient times in frame where Titan can have no soul but be damaged, e.g. immediately after embark
		return

	if ( damage > 0 )
		AdjustVelocityFromHit( player, damageInfo, attacker, damage, critHit )

	if ( IsDemigod( player ) )
		EntityDemigod_TryAdjustDamageInfo( player, damageInfo )

	bool critHit = false
	if ( CritWeaponInDamageInfo( damageInfo ) )
		critHit = IsCriticalHit( attacker, player, DamageInfo_GetHitBox( damageInfo ), DamageInfo_GetDamage( damageInfo ), DamageInfo_GetDamageType( damageInfo ) )

	if ( critHit )
		DamageInfo_AddCustomDamageType( damageInfo, DF_CRITICAL )

	#if MP
		if ( HeavyArmorCriticalHitRequired( damageInfo ) && CritWeaponInDamageInfo( damageInfo ) && !critHit && IsValid( attacker ) && !attacker.IsTitan())
		{
			float shieldHealth = float( player.GetTitanSoul().GetShieldHealth() )
			if ( shieldHealth - damage <= 0 )
			{
				if ( shieldHealth > 0 )
					DamageInfo_SetDamage( damageInfo, shieldHealth )
				else
					DamageInfo_SetDamage( damageInfo, 0 )
			}
		}
	#endif

	PlayerOrNPCTitanTookDamage( player, damageInfo, critHit, titanDamage )
}

bool function IsKillshot( entity ent, var damageInfo, entity titanSoul )
{
	float damage = DamageInfo_GetDamage( damageInfo )
	int health = ent.GetHealth()

	if ( health - damage > DOOMED_MIN_HEALTH )
		return false

	return true
}

bool function ShouldDoomTitan( entity ent, var damageInfo )
{
	if ( DoomStateDisabled() )
		return false

	if ( GetDoomedState( ent ) )
		return false

	if ( DamageInfo_GetForceKill( damageInfo ) )
		return false

	float doomedHealth = GetTitanSoulDoomedHealth( ent.GetTitanSoul() )
	if ( doomedHealth <= 0 )
		return false

	entity soul = ent.GetTitanSoul()
	if ( soul.soul.skipDoomState )
		return false

	if ( DamageInfo_GetCustomDamageType( damageInfo ) & DF_SKIP_DAMAGE_PROT )
		return doomedHealth > ( DamageInfo_GetDamage( damageInfo ) - ent.GetHealth() )

	bool skipDoom = ( DamageInfo_GetCustomDamageType( damageInfo ) & DF_SKIPS_DOOMED_STATE ) > 0
	return !skipDoom
}

bool function HandleKillshot( entity ent, var damageInfo, TitanDamage titanDamage )
{
	/* // handling in normal checks below!
	#if NPC_TITAN_PILOT_PROTOTYPE
		if ( TitanHasNpcPilot( ent ) ) //an npc titan that was dropped by an npc human
		{
			float damage = DamageInfo_GetDamage( damageInfo )
			int health = ent.GetHealth()

			if ( health - damage <= 0 )
			{
				DamageInfo_SetDamage( damageInfo, 0 )
				thread TitanEjectPlayer( ent )
			}

			return
		}
	#endif
	*/

	if ( ent.IsPlayer() && ent.IsBuddhaMode() )
		return false

	entity titanSoul = ent.GetTitanSoul()

	if ( IsKillshot( ent, damageInfo, titanSoul ) )
	{
		entity boss = titanSoul.GetBossPlayer()
		Soul_SetLastAttackInfo( titanSoul, damageInfo )

		if ( ShouldDoomTitan( ent, damageInfo ) )
		{
			// Added via AddCallback_OnTitanDoomed
			foreach ( callbackFunc in svGlobal.onTitanDoomedCallbacks )
			{
				callbackFunc( ent, damageInfo )
			}

			if ( IsMultiplayer() )
			{
				entity attacker = expect entity( expect table( titanSoul.lastAttackInfo ).attacker )
				if ( IsValid( attacker ) )
				{
					entity bossPlayer = attacker.GetBossPlayer()
					if ( attacker.IsNPC() && IsValid( bossPlayer ) )
						attacker = bossPlayer

					if ( attacker.IsPlayer() )
						ScoreEvent_TitanDoomed( ent, attacker, damageInfo )
				}
			}
			
			// modified: npc pilots condition
			#if NPC_TITAN_PILOT_PROTOTYPE
				if ( TitanHasNpcPilot( ent ) ) //an npc titan that was dropped by an npc human
					thread NpcPilotEjectingThink( ent )
			#endif
			//

			thread DoomedHealthThink( titanSoul, damageInfo )

			titanDamage.doomedNow = true
			titanDamage.doomedDamage = int( DamageInfo_GetDamage( damageInfo ) )

			int health = ent.GetHealth()
			DamageInfo_SetDamage( damageInfo, health - 1 )
			return true
		}
		else
		{
			// handle auto eject here
			if ( ent.IsPlayer() && PlayerHasAutoEject( ent ) )
		    {
			    int health = ent.GetHealth()
			    DamageInfo_SetDamage( damageInfo, health - 1 )
			    thread HandleAutoEject( ent, titanSoul )
				return false
			}
		}
	}

	// Handle doom state damage
	if ( GetDoomedState( ent ) )
	{
		// as long as we're dying but not yet ejecting, the last player to damage us gets credit
		if ( titanSoul.IsEjecting() )
		{
			Soul_SetLastAttackInfo( titanSoul, damageInfo )
		}
		else if ( ent.IsPlayer() && PlayerHasAutoEject( ent ) ) //Handle auto eject for when the frame in which Titan became doomed was not valid for ejecting, e.g. melee
		 {
			int health = ent.GetHealth()
			DamageInfo_SetDamage( damageInfo, health - 1 )
			thread HandleAutoEject( ent, titanSoul )
			return false
		 }

		// protect players who eject early
		// if ( ent.IsPlayer() && IsEjectProtected( ent, damageInfo ) )
		// 	DamageInfo_SetDamage( damageInfo, 0 )

		// slight protection to prevent multiple rapid damage events from eating through doomed state health
		if ( Time() - titanSoul.soul.doomedStartTime < TITAN_DOOMED_INVUL_TIME && !DamageInfo_GetForceKill( damageInfo ) )
			DamageInfo_SetDamage( damageInfo, 0 )
	}
	else
	{
		Soul_SetLastAttackInfo( titanSoul, damageInfo )
	}

	return false
}

bool function PlayerHasAutoEject( entity player )
{
	if ( player.IsBot() )
		return false

	if ( !PlayerHasPassive( player, ePassives.PAS_AUTO_EJECT ) )
		return false

	return true
}

void function AdjustVelocityFromHit( entity player, var damageInfo, entity attacker, float damage, bool critHit )
{
/*
	if ( DamageInfo_GetDamageCriticalHitScale( damageInfo ) > 1.0 )
	{
		// if you can crit, you have to crit!
		if ( !critHit )
			return
	}
*/

	//printt( " " )
	//printt( "damage: " + damage )

	vector damageForward = DamageInfo_GetDamageForce( damageInfo )
	damageForward.z = 0
	//printt( "damageForward " + damageForward )

	damageForward.Norm()

	//vector org = DamageInfo_GetDamagePosition( damageInfo )
	//DebugDrawLine( org, org + damageForward * 250, 255, 0, 0, true, 5.0 )

	vector velocity = player.GetVelocity()
	vector velForward = player.GetVelocity()
	velForward.z = 0
	velForward.Norm()

	//DebugDrawLine( org, org + velForward * 250, 0, 255, 0, true, 5.0 )

	float dot = DotProduct( velForward, damageForward )

	// only stop from the ~front cone
	if ( dot >= -0.5 )
		return

	float speedPercent

	switch ( DamageInfo_GetDamageSourceIdentifier( damageInfo ) )
	{
		//case eDamageSourceId.mp_titanweapon_40mm:
		//	speedPercent = GraphCapped( damage, 0, 750, 1, 0 )
		//	break

		case eDamageSourceId.mp_titanweapon_xo16:
			speedPercent = 0.075
			break

		default:
			speedPercent = GraphCapped( damage, 0, 2500, 0, 1.0 )
	}

	//float dif = GraphCapped( dot, -1, -0.5, 1, 0 )
	//speedPercent = speedPercent * dif + ( 1.0 - dif )

	speedPercent *= GraphCapped( dot, -1.0, -0.5, 1, 0 )

	//printt( " " )
	//printt( "Damage: " + damage )
	//printt( "dot: " + dot )
	//printt( "speedPercent: " + speedPercent )
	speedPercent = 1.0 - speedPercent
	// make the dot into a tighter range
	//dot += 0.5
	//dot *= -2.0

	//printt( "modifier: " + ( speedPercent ) )
	velocity *= ( speedPercent )
	player.SetVelocity( velocity )
}



void function DoomedHealthThink( entity titanSoul, var damageInfo )
{
	Assert( expect table( titanSoul.lastAttackInfo ).attacker, "Player entered reserve health with no attacker" )

	entity soulOwner = titanSoul.GetTitan()
	Assert( IsValid( soulOwner ), "Invalid owner " + soulOwner )

	titanSoul.soul.doomedStartTime = Time()

	// kill any existing health regen thread
	titanSoul.Signal( SIGNAL_TITAN_HEALTH_REGEN )
	titanSoul.Signal( SIGNAL_TITAN_SHIELD_REGEN )

	titanSoul.EndSignal( "OnDestroy" )
	titanSoul.EndSignal( "OnTitanDeath" )
	// vanilla missing: disabling doomed health loss on certain condition
	titanSoul.Signal( "DoomedHealthThink" )
	titanSoul.EndSignal( "DoomedHealthThink" )
	// vanilla missing: disabling doomed health loss on undoomed
	titanSoul.EndSignal( "TitanUnDoomed" )

	float tickRate = 0.15
	float maxDoomedHealth = GetTitanSoulDoomedHealth( titanSoul )
	float doomedHealth = maxDoomedHealth
	if (  DamageInfo_GetCustomDamageType( damageInfo ) & DF_SKIP_DAMAGE_PROT )
		doomedHealth = min( doomedHealth + soulOwner.GetHealth() - DamageInfo_GetDamage( damageInfo ), doomedHealth )

	float DPS = (doomedHealth / TITAN_DOOMED_MAX_DURATION )

	titanSoul.EnableDoomed()
	titanSoul.doomedTime = Time()
	soulOwner.SetDoomed() // start doomed animation
	DoomTitan( soulOwner )
	soulOwner.Signal( "Doomed" )
	titanSoul.Signal( "Doomed" )

	// allow the damage to go through before resetting the health, so that we get proper damage indicators, etc...
	// this process should also be in code
	WaitEndFrame()

	// grab the soul owner again since there was a wait
	soulOwner = titanSoul.GetTitan()
	if ( !IsValid( soulOwner ) )
		return

	// For fakeBT( and other modded conditions ), we can set whether to use infinite doom
	bool isInfiniteDoom = TitanHealth_GetSoulInfiniteDoomedState( titanSoul )

	//if ( PROTO_AlternateDoomedState() )
	if ( isInfiniteDoom )
	{
		//printt( soulOwner.GetHealth() )
		//soulOwner.SetHealth( doomedHealth ) // set health should be done after SetMaxHealth()
		soulOwner.SetMaxHealth( maxDoomedHealth )
		// anti-crash
		if ( doomedHealth > maxDoomedHealth )
			doomedHealth = maxDoomedHealth
		soulOwner.SetHealth( doomedHealth )
		//soulOwner.SetHealthPerSegment( 0 )

		soulOwner.ClearDoomed() // disable doomed animation

		if ( soulOwner.IsPlayer() && PlayerHasAutoEject( soulOwner ) )
		{
			HandleAutoEject( soulOwner, titanSoul )
		}
		else
		{
			//If it's an auto-titan with auto-eject, this just instantly kills it.
			var attacker = ( "attacker" in titanSoul.lastAttackInfo ) ? expect table( titanSoul.lastAttackInfo ).attacker : null
			expect entity( attacker )
			var inflictor = ( "inflictor" in titanSoul.lastAttackInfo ) ? expect table( titanSoul.lastAttackInfo ).inflictor : null
			expect entity( inflictor )
			var damageSource = ( "damageSourceId" in titanSoul.lastAttackInfo ) ? expect table( titanSoul.lastAttackInfo ).damageSourceId : -1
			int damageFlags =  expect int( expect table( titanSoul.lastAttackInfo ).scriptType )
			if ( SoulHasPassive( titanSoul, ePassives.PAS_AUTO_EJECT ) )
			{
				int scriptDamageType = damageTypes.titanEjectExplosion | damageFlags
				soulOwner.Die( attacker, inflictor, { scriptType = scriptDamageType, damageSourceId = damageSource } )
			}
		}
		return
	}

	// doomed health loss version
	//soulOwner.SetHealth( doomedHealth ) // set health should be done after SetMaxHealth()
	soulOwner.SetMaxHealth( maxDoomedHealth )
	// anti-crash
	if ( doomedHealth > maxDoomedHealth )
		doomedHealth = maxDoomedHealth
	soulOwner.SetHealth( doomedHealth )
	//soulOwner.SetHealthPerSegment( 0 )

	// vanilla missing!
	// for players, clean their doomed state(which handles animation), or their replacement titans will always flinching
	OnThreadEnd
	(
		function(): ( soulOwner )
		{
			if ( IsValid( soulOwner ) )
				soulOwner.ClearDoomed()
		}
	)
	//

	string settings = GetSoulPlayerSettings( titanSoul )
	float damageMod = 1.0

	while ( true )
	{
		table lastAttackInfo = expect table( titanSoul.lastAttackInfo )

		table extraDeathInfo = {}
		extraDeathInfo.scriptType <- (DF_NO_INDICATOR | DF_DOOMED_HEALTH_LOSS)
		if ( expect int( lastAttackInfo.scriptType ) & DF_BURN_CARD_WEAPON )
			extraDeathInfo.scriptType = expect int( extraDeathInfo.scriptType ) | DF_BURN_CARD_WEAPON
		if ( expect int( lastAttackInfo.scriptType ) & DF_VORTEX_REFIRE )
			extraDeathInfo.scriptType = expect int( extraDeathInfo.scriptType ) | DF_VORTEX_REFIRE

		// should always be despawn. don't let this function triggering any of the damageSourceIdCallbacks
		// also can't use suicide. it's a kind of force kill which can kill the titan while they're invulnerable
		// for proper obit, change to desired damageSourceId if we're about to perform a killshot
		//extraDeathInfo.damageSourceId <- lastAttackInfo.damageSourceId
		extraDeathInfo.damageSourceId <- damagedef_despawn

		entity soulOwner = titanSoul.GetTitan()
		if ( !IsValid( soulOwner ) )
			return
		if ( soulOwner.IsPlayer() )
		{
			//if ( PlayerHasPassive( soulOwner, ePassives.PAS_DOOMED_TIME ) )
			//	damageMod = 0.4
			//else
			//	damageMod = 1.0

			// modified for modded titan doomed state
			if( titanSoul in file.soulDoomedHealthLossDamage )
				damageMod = file.soulDoomedHealthLossDamage[ titanSoul ]
			//

			// re-enabled this, change to multiplier
			if ( PlayerHasPassive( soulOwner, ePassives.PAS_DOOMED_TIME ) )
				damageMod *= 0.4 // less doomed damage if passive valid

			if ( PlayerHasAutoEject( soulOwner ) )
			{
				//printt( "About to Auto Eject" )
				// do it in the loop cause player could somehow get in a titan in doomed state
				HandleAutoEject( soulOwner, titanSoul )
			}
		}

		float dmgAmount = DPS * tickRate * damageMod

		// needs to update attacker and inflictor, if attacker turns to invalid, it will automatically assign to worldspawn
		// if worldspawn triggering some damageSourceIdCallback(mostly ttf2 ones, like scorch's and legion's weapons), game's gonna crash
		// EDIT: health loss should always be self damage. otherwise player can earn extra core meter from it
		/*
		entity healthLossAttacker = expect entity( lastAttackInfo.attacker )
		entity healthLossInflictor = expect entity( lastAttackInfo.inflictor )
		bool attackerValid = IsValid( healthLossAttacker ) && !IsWorldSpawn( healthLossAttacker )
		if ( !attackerValid )
			healthLossAttacker = soulOwner // attacker invalid, turns to self damage
		if ( attackerValid && !IsValid( healthLossInflictor ) ) // attacker valid but inflictor invalid
			healthLossInflictor = healthLossAttacker // re-assign attacker as inflictor
		*/

		entity lastAttacker = expect entity( lastAttackInfo.attacker )
		bool attackerValid = IsValid( lastAttacker ) && !IsWorldSpawn( lastAttacker )
		entity healthLossAttacker = soulOwner

		// killshot: add proper obit
		bool isKillshot = dmgAmount >= soulOwner.GetHealth()
		if ( isKillshot && !soulOwner.IsInvulnerable() ) // defensive fix
		{
			if ( attackerValid ) // get attacker validation
			{
				healthLossAttacker = lastAttacker // attacker valid! re-assign for proper score event and obit
				extraDeathInfo.damageSourceId = lastAttackInfo.damageSourceId
			}
			else // attacker invalid or has been re-assigned
				extraDeathInfo.damageSourceId = damagedef_suicide
		}

		//soulOwner.TakeDamage( dmgAmount, expect entity( lastAttackInfo.attacker ), expect entity( lastAttackInfo.inflictor ), extraDeathInfo )
		//soulOwner.TakeDamage( dmgAmount, healthLossAttacker, healthLossInflictor, extraDeathInfo )
		soulOwner.TakeDamage( dmgAmount, healthLossAttacker, healthLossAttacker, extraDeathInfo )
		//print( "Doomded health loss dmgAmount: " + string( dmgAmount ) )

		wait tickRate
	}
}

void function HandleAutoEject( entity rider, entity soul )
{
	soul.EndSignal( "OnDestroy" )
	soul.EndSignal( "OnTitanDeath" )

	thread TitanEjectPlayer( rider )
	if ( soul.IsEjecting() )
	{
		 // so we don't cloak the titan during the ejection animation
		if ( GetNuclearPayload( rider ) > 0 )
			wait 2.0
		else
			wait 1.0

		EnableCloak( rider, 7.0 )
		return
	}
}

void function TitanShieldRegenThink( entity soul )
{
	// debug
#if TITAN_SCRIPTED_SHIELD_REGEN_DEBUG
	TitanHealth_SetSoulEnableShieldRegen( soul, true )
	TitanHealth_SetSoulShieldRegenDelay( soul, TITAN_SHIELD_REGEN_DELAY )
	TitanHealth_SetSoulShieldRegenTime( soul, TITAN_SHIELD_REGEN_TIME )
	TitanHealth_SetSoulShieldDamageReductionScale( soul, 0.75 )
	TitanHealth_SetSoulInfiniteDoomedState( soul, false )
#endif

	thread TitanShieldRegenThink_Internal( soul )
}

// HACK: this technically doesn't work properly because server framerate and all that jazz. Should really be in code.
void function TitanShieldRegenThink_Internal( entity soul )
{
	soul.EndSignal( "OnDestroy" )
	soul.EndSignal( "Doomed" )
	soul.EndSignal( "StopShieldRegen" )

	//Shield starts at 0 health for now
	string settings = GetSoulPlayerSettings( soul )
	bool hasShield = Dev_GetPlayerSettingByKeyField_Global( settings, "start_with_shields" ) == 1
	// modified, titans from scripted shield regen starts from max shield
	bool startFromMaxShield = false
	if ( soul in file.soulEnableShieldRegen )
		startFromMaxShield = file.soulEnableShieldRegen[ soul ]
	//

	// modified, titans from scripted shield regen starts from max shield
	//if ( !hasShield )
	//	soul.SetShieldHealth( 0 )
	if ( startFromMaxShield )
		soul.SetShieldHealth( soul.GetShieldHealthMax() )
	else if ( !hasShield )
		soul.SetShieldHealth( 0 )

	int lastShieldHealth = soul.GetShieldHealth()
	bool shieldHealthSound = false
	int maxShield = soul.GetShieldHealthMax() // what if we update max shield mid-time?
	float lastTime = Time()

// debug
#if TITAN_SCRIPTED_SHIELD_REGEN_DEBUG
	bool healthSetup = false
	int loopCount = 0
#endif

	while ( true )
	{
		entity titan = soul.GetTitan()
		if ( !IsValid( titan ) )
			return

// debug
#if TITAN_SCRIPTED_SHIELD_REGEN_DEBUG
		if ( !healthSetup && loopCount > 1 )
		{
			//print( "Settting up debug titan health!" )
			int segments = titan.GetMaxHealth() / 2500
			soul.SetShieldHealthMax( segments * 1250 )
			soul.SetShieldHealth( soul.GetShieldHealthMax() )
			titan.SetMaxHealth( segments * 1500 ) // 1500 health per segment
			titan.SetHealth( titan.GetMaxHealth() )
			healthSetup = true
		}
		loopCount += 1
#endif

		int shieldHealth = soul.GetShieldHealth()
		maxShield = soul.GetShieldHealthMax() // what if we update max shield mid-time?
		Assert( titan )

		if ( lastShieldHealth <= 0 && shieldHealth && titan.IsPlayer() )
		{
		 	EmitSoundOnEntityOnlyToPlayer( titan, titan, "titan_energyshield_up_1P" )
		 	shieldHealthSound = true
		 	if ( titan.IsTitan() )
		 	{
		 		GiveFriendlyRodeoPlayerProtection( titan )
		 	}
		 	else
		 	{
		 		if ( titan.IsPlayer() )
		 		{
		 			printt( "Player was " + titan.GetPlayerSettings() )
		 		}

		 		printt( "ERROR! Expected Titan, but got " + titan )
		 	}
		}
		else if ( shieldHealthSound && shieldHealth == soul.GetShieldHealthMax() )
		{
			shieldHealthSound = false
		}
		else if ( lastShieldHealth > shieldHealth && shieldHealthSound )
		{
		 	StopSoundOnEntity( titan, "titan_energyshield_up_1P" )
		 	shieldHealthSound = false
		}

		if ( Time() >= soul.nextRegenTime && TitanHasRegenningShield( soul ) )
		{
			float shieldRegenRate = maxShield / ( GetShieldRegenTime( soul ) / SHIELD_REGEN_TICK_TIME )

			if ( SoulHasPassive( soul, ePassives.PAS_SHIELD_BOOST ) )
				shieldRegenRate = SHIELD_BEACON_REGEN_RATE

			float frameTime = max( 0.0, Time() - lastTime )
			shieldRegenRate = shieldRegenRate * frameTime / SHIELD_REGEN_TICK_TIME
			// Faster shield recharge if we have Fusion Core active ability ( Stryder Signature )
			//if ( titan.IsPlayer() && PlayerHasPassive( titan, ePassives.PAS_FUSION_CORE ) )
			//	shieldRegenRate *= 1.25

			soul.SetShieldHealth( minint( soul.GetShieldHealthMax(), int( shieldHealth + shieldRegenRate ) ) )
		}

		lastShieldHealth = shieldHealth
		lastTime = Time()
		WaitFrame()
	}
}

float function GetShieldRegenTime( entity soul )
{
	// modified, get rid of hardcode
	/*
	float time
	if ( SoulHasPassive( soul, ePassives.PAS_SHIELD_REGEN ) )
		time = TITAN_SHIELD_REGEN_TIME * 0.5
	else
		time = TITAN_SHIELD_REGEN_TIME
	*/

	float time = TITAN_SHIELD_REGEN_TIME

	if ( soul in file.soulShieldRegenTime )
		time = file.soulShieldRegenDelay[ soul ]

	if ( SoulHasPassive( soul, ePassives.PAS_SHIELD_REGEN ) )
		time *= 0.5

	return time
}

float function GetHealthRegenDelay( entity soul )
{
	if ( GetDoomedState( soul.GetTitan() ) )
		return TITAN_DOOMED_REGEN_DELAY

	return GetShieldRegenDelay( soul )
}

float function GetShieldRegenDelay( entity soul )
{
	float regenDelay = TITAN_SHIELD_REGEN_DELAY

	string settings = GetSoulPlayerSettings( soul )
	regenDelay = expect float( Dev_GetPlayerSettingByKeyField_Global( settings, "titan_regen_delay" ) )

	// modified to get rid of stupid code
	/*
	float delay
	if ( SoulHasPassive( soul, ePassives.PAS_SHIELD_REGEN ) )
		delay = regenDelay - 1.0
	else
		delay = regenDelay
	*/

	float delay = regenDelay
	if ( soul in file.soulShieldRegenDelay )
		delay = file.soulShieldRegenDelay[ soul ]
	if ( SoulHasPassive( soul, ePassives.PAS_SHIELD_REGEN ) )
		delay = regenDelay - 1.0

	if ( SoulHasPassive( soul, ePassives.PAS_SHIELD_BOOST ) ) // WTF?
		delay = 2.0

	return delay
}

void function RecordDamageToNPCTitanSoul( entity soul, var damageInfo )
{
	float damage = DamageInfo_GetDamage( damageInfo )

	vector inflictOrigin = <0.0,0.0,0.0>
	entity inflictor = DamageInfo_GetInflictor( damageInfo )
	if ( IsValid( inflictor ) )
		inflictOrigin = inflictor.GetOrigin()

	entity attacker = DamageInfo_GetAttacker( damageInfo )

	entity weapon = DamageInfo_GetWeapon( damageInfo )
	array<string> weaponMods
	if ( IsValid( weapon ) )
		weaponMods = weapon.GetMods()

	StoreDamageHistoryAndUpdate( soul, TITAN_HEALTH_HISTORY_FALLOFF_END, damage, inflictOrigin, DamageInfo_GetCustomDamageType( damageInfo ), DamageInfo_GetDamageSourceIdentifier( damageInfo ), attacker, weaponMods )
}

void function AutoTitan_TryMultipleTitanCallout( entity titan, var damageInfo )
{
	array<entity> titans = GetTitansHitMeInTime( titan.GetTitanSoul(), 5 )
	entity enemy = titan.GetEnemy()
	if ( IsAlive( enemy )  && enemy.IsTitan() && !titans.contains( enemy ) )
		titans.append( enemy )

	int totalEngagedTitans = titans.len()

	if ( totalEngagedTitans == 1 )
		PlayAutoTitanConversation( titan, "autoEngageTitan" )
	else if ( totalEngagedTitans > 1 )
		PlayAutoTitanConversation( titan, "autoEngageTitans" )
}

float function CalculateNextRegenTime( float damage, int damageType, bool critHit, float oldNextRegenTime, float maxRegenDelay )
{
	if ( damage >= TITAN_REGEN_MIN_DAMAGE || critHit || damageType & DF_STOPS_TITAN_REGEN )
	{
		if ( PROTO_VariableRegenDelay() )
		{
			// regen delay based on damage dealt
			float minRegenDelay = 1.0
			float regenDelay = GraphCapped( damage, 100, 1000, minRegenDelay, maxRegenDelay )

			float nextRegenTime = oldNextRegenTime
			float delayBasedOnCurrentTime = Time() + regenDelay
			float delayBasedOnPreviousDelay = nextRegenTime + regenDelay
			maxRegenDelay = Time() + maxRegenDelay

			delayBasedOnCurrentTime = min( delayBasedOnCurrentTime, maxRegenDelay )
			delayBasedOnPreviousDelay = min( delayBasedOnPreviousDelay, maxRegenDelay )
			nextRegenTime = max( delayBasedOnCurrentTime, delayBasedOnPreviousDelay )

			return nextRegenTime
		}
		else
		{
			// old style
			return Time() + maxRegenDelay
		}
	}
	else
	{
		float addTime = TITAN_REGEN_MIN_DAMAGE_DELAY

		if ( oldNextRegenTime <= Time() + addTime )
			return Time() + addTime
	}

	return oldNextRegenTime
}

void function AddCreditToTitanCoreBuilderForTitanDamageInflicted( entity titanAttacker, float damage )
{
	Assert( TitanDamageRewardsTitanCoreTime() )

	float rateRaw = CORE_BUILD_PERCENT_FROM_TITAN_DAMAGE_INFLICTED
	float rate = (rateRaw * 0.01)
	float credit = (rate * damage)
	if ( credit > 0.0 )
		AddCreditToTitanCoreBuilder( titanAttacker, credit )
}

void function AddCreditToTitanCoreBuilderForTitanDamageReceived( entity titanVictim, float damage )
{
	Assert( TitanDamageRewardsTitanCoreTime() )

	float rateRaw = CORE_BUILD_PERCENT_FROM_TITAN_DAMAGE_RECEIVED
	float rate = (rateRaw * 0.01)
	float credit = (rate * damage)
	if ( credit > 0.0 )
		AddCreditToTitanCoreBuilder( titanVictim, credit )
}

void function AddCreditToTitanCoreBuilderForDoomInflicted( entity titanAttacker )
{
	Assert( TitanDamageRewardsTitanCoreTime() )

	float valueRaw = CORE_BUILD_PERCENT_FROM_DOOM_INFLICTED
	float credit = (valueRaw * 0.01)
	if ( credit > 0.0 )
		AddCreditToTitanCoreBuilder( titanAttacker, credit )
}

void function AddCreditToTitanCoreBuilderForDoomEntered( entity titanVictim )
{
	Assert( TitanDamageRewardsTitanCoreTime() )

	float valueRaw = CORE_BUILD_PERCENT_FROM_DOOM_ENTERED
	float credit = (valueRaw * 0.01)
	if ( credit > 0.0 )
		AddCreditToTitanCoreBuilder( titanVictim, credit )
}

void function AddCreditToTitanCoreBuilder( entity titan, float credit )
{
	Assert( TitanDamageRewardsTitanCoreTime() )

	entity soul = titan.GetTitanSoul()
	if ( !IsValid( soul ) )
		return

	entity bossPlayer = soul.GetBossPlayer()

	if ( titan.IsPlayer() )
	{
		if ( !IsValid( bossPlayer ) )
			return

		if ( bossPlayer.IsTitan() && TitanCoreInUse( bossPlayer ) )
			return
	}
	else
	{
		Assert( titan.IsNPC() )
		if ( TitanCoreInUse( titan ) )
			return
	}

	if ( !IsAlive( titan ) )
		return

	// vanilla missing check for titan core weapon avaibility
	entity coreWeapon = titan.GetOffhandWeapon( OFFHAND_EQUIPMENT )
	if ( !IsValid( coreWeapon ) )
		return
	//

	if ( SoulHasPassive( soul, ePassives.PAS_VANGUARD_COREMETER ) )
		credit *= 1.10

	credit *= file.earn_meter_titan_multiplier
	#if MP
	if ( titan.IsPlayer() )
	{
		float coreModifier = titan.GetPlayerNetFloat( "coreMeterModifier" )
		if ( coreModifier >= 0.5 )
			credit *= FD_HOT_STREAK_MULTIPLIER
	}
	#endif

	// modified to get rid of respawn's hardcode
	credit *= TitanHealth_GetTitanCoreBuilderMultiplier( titan )
	//

	bool coreWasAvailable = false

	if ( IsValid( bossPlayer ) )
		coreWasAvailable = IsCoreChargeAvailable( bossPlayer, soul )

	float oldTotalCredit = SoulTitanCore_GetNextAvailableTime( soul )
	float newTotalCredit = (credit + oldTotalCredit)
	if ( newTotalCredit >= 0.998 ) //JFS - the rui has a +0.001 for showing the meter as full. This fixes the case where the core meter displays 100 but can't be fired.
		newTotalCredit = 1.0
	SoulTitanCore_SetNextAvailableTime( soul, newTotalCredit )

	if ( IsValid( bossPlayer ) && !coreWasAvailable && IsCoreChargeAvailable( bossPlayer, soul ) )
	{
		AddPlayerScore( bossPlayer, "TitanCoreEarned", bossPlayer )
		#if MP
			UpdateTitanCoreEarnedStat( bossPlayer, titan )
			PIN_PlayerAbilityReady( bossPlayer, "core" )
		#endif
	}

	#if MP
	// remove bossplayer checks here, also give npc earnmeter rewards
	// we handle smoke usage by PlayerEarnMeter_EnableSoulNPCTitanEarnMeterSmokeUsage()
	//if ( IsValid( bossPlayer ) )
		JFS_PlayerEarnMeter_CoreRewardUpdate( titan, oldTotalCredit, newTotalCredit )
	#endif

	#if HAS_TITAN_TELEMETRY
	if ( titan.IsPlayer() )
	{
		if ( IsCoreChargeAvailable( titan, soul ) )
		{
			TitanHints_TryShowHint( titan, [OFFHAND_EQUIPMENT] )
		}
	}
	#endif
}

float function GetTitanCoreTimer( entity titan )
{
	Assert( titan.IsTitan() )
	entity soul = titan.GetTitanSoul()
	Assert( soul )

	return SoulTitanCore_GetNextAvailableTime( soul ) - Time()
}



void function SetTitanCoreTimer( entity titan, float timeDiff )
{
	Assert( !TitanDamageRewardsTitanCoreTime() )

	Assert( titan.IsTitan() )
	entity soul = titan.GetTitanSoul()
	Assert( soul )

	float newTime = Time() + timeDiff
	SoulTitanCore_SetNextAvailableTime( soul, max( Time() - 1, newTime ) )
}


void function Titan_MonarchCleanup( entity soul, var damageInfo )
{
	entity titan = soul.GetTitan()

	if ( !IsValid( titan ) )
		return

	int statesIndex = titan.FindBodyGroup( "states" )
	if ( statesIndex <= -1 )
		return

	titan.SetBodygroup( statesIndex, 2 )
}


// vanilla missing callback
void function AddCallback_OnTitanUndoomed( void functionref( entity, int ) callbackFunc )
{
	file.titanUndoomedCallbacks.append( callbackFunc )
}

// modified default shield modifier
void function TitanShieldModifier( entity ent, var damageInfo, ShieldDamageModifier shieldModifier )
{
	if ( !IsValid( ent ) || !ent.IsTitan() )
		return
	entity soul = ent.GetTitanSoul()
	if ( !IsValid( soul ) )
		return

	// taken from Titan_NPCTookDamage() and Titan_PlayerTookDamage(), removed #if MP
	// checking whether this is a damage using non-titan-damage weapon
	bool critHit = false
	if ( CritWeaponInDamageInfo( damageInfo ) )
		critHit = IsCriticalHit( DamageInfo_GetAttacker( damageInfo ), ent, DamageInfo_GetHitBox( damageInfo ), DamageInfo_GetDamage( damageInfo ), DamageInfo_GetDamageType( damageInfo ) )

	entity attacker = DamageInfo_GetAttacker( damageInfo )
	if ( HeavyArmorCriticalHitRequired( damageInfo ) && CritWeaponInDamageInfo( damageInfo ) && !critHit && IsValid( attacker ) && !attacker.IsTitan())
		return

	if ( soul in file.soulShieldDamageReductionScale )
	{
		shieldModifier.permanentDamageFrac = 1.0 - file.soulShieldDamageReductionScale[ soul ]

		// specific damage, removed for now
		//print( "IsRodeoDamage(): " + string( IsRodeoDamage( soul, damageInfo ) ) )
		//print( "IsRodeoDamageFromBatteryPack(): " + string( IsRodeoDamageFromBatteryPack( soul, damageInfo ) ) )
		//if ( IsRodeoDamage( soul, damageInfo ) )
		//	shieldModifier.permanentDamageFrac = 1.0 // take full damage from rodeo
	}
}


// modded function
#if NPC_TITAN_PILOT_PROTOTYPE
const float NPC_PILOT_EJECTING_DELAY = 5.0
const float NPC_PILOT_EJECTING_DELAY_HEALTH_LOSS_FRAC = 0.6 // pilots do fast eject if they have health loss

void function NpcPilotEjectingThink( entity titan )
{
	if( !TitanHasNpcPilot( titan ) )
		return
	
	titan.EndSignal( "OnDeath" )
	titan.EndSignal( "OnDestroy" )
	entity soul = titan.GetTitanSoul()
	soul.EndSignal( "OnDestroy" )

	float ejectDelay = GetSoulNPCPilotEjectDelay( soul )
	if ( ejectDelay < 0 ) // delay smaller than 0 consider as never eject!
		return

	if ( !TitanHealth_GetSoulInfiniteDoomedState( soul ) )
		ejectDelay *= NPC_PILOT_EJECTING_DELAY_HEALTH_LOSS_FRAC

	wait ejectDelay

	while( titan.Anim_IsActive() || TitanCoreInUse( titan ) )
		WaitFrame() // wait till some animation and core ability end
	
	if( 
		titan.ContextAction_IsActive() || 
		titan.ContextAction_IsMeleeExecution() || 
		titan.ContextAction_IsMeleeExecutionTarget()
	) // executions, just return
		return

	thread TitanEjectPlayer( titan )
}
#endif

// modded titan core builder multiplier, get rid of respawn's hardcode
void function TitanHealth_SetTitanCoreBuilderMultiplier( entity titan, float multiplier )
{
	entity titanSoul = titan.GetTitanSoul()
	if ( !IsValid( titanSoul ) )
		return

	if ( !( titanSoul in file.soulCoreBuilderMultiplier ) )
		file.soulCoreBuilderMultiplier[ titanSoul ] <- 1.0 // default value
	file.soulCoreBuilderMultiplier[ titanSoul ] = multiplier
}

float function TitanHealth_GetTitanCoreBuilderMultiplier( entity titan )
{
	entity titanSoul = titan.GetTitanSoul()
	if ( !IsValid( titanSoul ) )
		return 1.0 // default value

	if ( !( titanSoul in file.soulCoreBuilderMultiplier ) )
		return 1.0

	return file.soulCoreBuilderMultiplier[ titanSoul ]
}

// modded titan doomed state
void function TitanHealth_SetSoulInfiniteDoomedState( entity titanSoul, bool infinite )
{
	if( !( titanSoul in file.soulInfiniteDoomedState ) )
		file.soulInfiniteDoomedState[ titanSoul ] <- PROTO_AlternateDoomedState() // default value
	file.soulInfiniteDoomedState[ titanSoul ] = infinite
}

bool function TitanHealth_GetSoulInfiniteDoomedState( entity titanSoul )
{
	if( !( titanSoul in file.soulInfiniteDoomedState ) )
		return PROTO_AlternateDoomedState() // default value
	return file.soulInfiniteDoomedState[ titanSoul ]
}

void function TitanHealth_SetSoulDoomedHealthLossDamage( entity titanSoul, float damageMod )
{
	if( !( titanSoul in file.soulDoomedHealthLossDamage ) )
		file.soulDoomedHealthLossDamage[ titanSoul ] <- 1.0 // default value
	file.soulDoomedHealthLossDamage[ titanSoul ] = damageMod
}

// modded titan shield regen, set shield regen per titan
void function TitanHealth_SetSoulEnableShieldRegen( entity titanSoul, bool enable )
{
	if ( !( titanSoul in file.soulEnableShieldRegen ) )
		file.soulEnableShieldRegen[ titanSoul ] <- false // default value
	file.soulEnableShieldRegen[ titanSoul ] = enable
}

// shared with _utility.gnut, function TitanHasRegenningShield()
bool function TitanHealth_GetSoulEnableShieldRegen( entity titanSoul )
{
	if ( !( titanSoul in file.soulEnableShieldRegen ) ) // not customized!
		return false
	return file.soulEnableShieldRegen[ titanSoul ]
}

void function TitanHealth_SetSoulShieldRegenDelay( entity titanSoul, float delay )
{
	if ( !( titanSoul in file.soulShieldRegenDelay ) )
		file.soulShieldRegenDelay[ titanSoul ] <- TITAN_SHIELD_REGEN_DELAY // default value
	file.soulShieldRegenDelay[ titanSoul ] = delay
}

void function TitanHealth_SetSoulShieldRegenTime( entity titanSoul, float regenTime )
{
	if ( !( titanSoul in file.soulShieldRegenTime ) )
		file.soulShieldRegenTime[ titanSoul ] <- TITAN_SHIELD_REGEN_TIME // default value
	file.soulShieldRegenTime[ titanSoul ] = regenTime
}

void function TitanHealth_SetSoulShieldDamageReductionScale( entity titanSoul, float damageReduction )
{
	if ( !( titanSoul in file.soulShieldDamageReductionScale ) ) // not customized!
		file.soulShieldDamageReductionScale[ titanSoul ] <- 1.0 - TITAN_SHIELD_PERMAMENT_DAMAGE_FRAC // ttf2 default is reduce all damages
	file.soulShieldDamageReductionScale[ titanSoul ] = damageReduction
}

// npc pilot
#if NPC_TITAN_PILOT_PROTOTYPE
void function TitanHealth_SetSoulNPCPilotEjectDelay( entity titanSoul, float ejectDelay )
{
	if ( !( titanSoul in file.soulNPCPilotEjectDelay ) )
		file.soulNPCPilotEjectDelay[ titanSoul ] <- NPC_PILOT_EJECTING_DELAY // default value
	file.soulNPCPilotEjectDelay[ titanSoul ] <- ejectDelay
}

float function GetSoulNPCPilotEjectDelay( entity soul )
{
	if ( !( soul in file.soulNPCPilotEjectDelay ) )
		return NPC_PILOT_EJECTING_DELAY // default value
	return file.soulNPCPilotEjectDelay[ soul ]
}
#endif